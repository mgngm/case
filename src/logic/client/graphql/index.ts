import type { GraphQLResult } from '@aws-amplify/api-graphql';
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
import { GraphQLAPI } from '@aws-amplify/api-graphql';
import type { AWSAppSyncRealTimeProvider } from '@aws-amplify/pubsub';
import type { NoInfer } from '@aws-amplify/ui';
import { isPlainObject } from '@reduxjs/toolkit';
// eslint-disable-next-line import/no-named-as-default
import type Observable from 'zen-observable-ts';
import type { ErrorPolicy } from 'src/logic/client/graphql/error';
import { defaultErrorPolicy, parseWithErrorPolicy } from 'src/logic/client/graphql/error';
import type {
  GraphQLOptions,
  PaginatedQuery,
  ReturnFromQuery,
  ReturnFromSubscription,
  VariablesFromQuery,
  VariablesFromQueryOrSubscription,
  VariablesFromSubscription,
} from 'src/logic/client/graphql/types';
import { assert } from 'src/logic/libs/helpers';
import type { IfHasRequiredKeys } from 'src/types/util';

export const isGraphQLResult = <T = unknown>(err: any): err is GraphQLResult<T> =>
  isPlainObject(err) && 'data' in err && 'errors' in err;

export type GraphQLConfig<PaginateKey extends keyof any, Policy extends ErrorPolicy = typeof defaultErrorPolicy> = {
  /**
   * Defaults to first key found in Object.keys from the result.
   * Set to `false` to disable pagination completely.
   */
  paginateKey?: PaginateKey | false;
  /**
   * 'None' will throw whenever the response contains errors
   *
   * 'Ignore' will ignore incoming errors and resolve like no errors occurred
   *
   * 'All' will return both the errors and data
   */
  errorPolicy?: Policy;
};

const hasNextPageToken = (
  result: GraphQLResult<any>,
  paginateKey: keyof any
): result is GraphQLResult<PaginatedQuery> => !!result.data?.[paginateKey]?.nextToken;

/**
 * Wraps Amplify's GraphQLAPI.graphQL function to automatically retrieve return and variables type from query provided.
 *
 * Error policy can also be provided.
 * @see parseWithErrorPolicy
 *
 * **Note**
 *
 * In most cases, you should be using a query that's already in the autogenerated map. If the map needs updating, run `npm run generate-graphql-map`.
 *
 * If you're using a custom query you intend to reuse but doesn't have autogenerated types, add it to GraphQLMapCustom in ./types.
 *
 * Either of the above will allow the function to retrieve all types automatically, so usage will look like below.
 * ```ts
 * const result = await graphQL({ query: getFoo, variables }); // variables is automatically GetFooQueryVariables and result is GraphQLResult<GetFooQuery>
 * ```
 *
 * If this is an entirely one off usage, you can provide the generics manually as below.
 * ```ts
 * const result = await graphQL<string, ReturnType, Variables, Policy>({ query: customQuery, variables }, undefined, policy); // note that `Policy` and `policy` are only required to pass if it's not the default
 * ```
 *
 * @param options - GraphQL options object, including query string and variables.
 * @param [additionalHeaders] - headers to merge in after any `graphql_headers` set in the config
 * @param [policy] - Error policy to parse with - defaults to 'all'
 * @returns Promise for GraphQL result - automatically cast to ReturnType
 *
 * @template Query - GraphQL string
 * @template ReturnType - type for result.data
 * @template Variables - type for options.variables
 * @template Policy - Error policy to parse with
 */
export const graphQL = async <
  Query extends string,
  ReturnType extends ReturnFromQuery<Query> = ReturnFromQuery<Query>,
  Variables extends VariablesFromQuery<Query> = VariablesFromQuery<Query>,
  Policy extends ErrorPolicy = typeof defaultErrorPolicy
>(
  options: GraphQLOptions<NoInfer<Variables>, Query>,
  additionalHeaders?: Parameters<typeof GraphQLAPI.graphql>[1],
  config?: GraphQLConfig<keyof ReturnType, Policy>
) => {
  const operationType = GraphQLAPI.getGraphqlOperationType(options.query);
  assert(operationType !== 'subscription', 'Please use `graphQLSubscription` for subscriptions');
  const { errorPolicy = defaultErrorPolicy } = config ?? {};
  // now a safe assertion... mostly
  const result = await (
    GraphQLAPI.graphql({ ...options, variables: { ...options.variables, limit: 9999 } }, additionalHeaders) as Promise<
      GraphQLResult<ReturnType>
    >
  ).catch((e) => {
    if (isGraphQLResult<ReturnType>(e)) {
      // this grossness brought to you by API.graphql throwing the result if there are *any* errors
      return e;
    } else {
      throw e;
    }
  });
  if (operationType === 'query') {
    const { paginateKey = Object.keys((result.data as object) ?? {})[0] as keyof ReturnType | undefined } =
      config ?? {};
    if (paginateKey && hasNextPageToken(result, paginateKey)) {
      while (result.data?.[paginateKey]?.nextToken) {
        const nextResult = await (
          GraphQLAPI.graphql(
            {
              ...options,
              variables: { ...options.variables, limit: 9999, nextToken: result.data?.[paginateKey]?.nextToken },
            },
            additionalHeaders
          ) as Promise<GraphQLResult<ReturnType & PaginatedQuery>>
        ).catch((e) => {
          if (isGraphQLResult<ReturnType & PaginatedQuery>(e)) {
            return e;
          } else {
            throw e;
          }
        }); // now a safe assertion... mostly
        // do we want an early bail if the result doesn't pass the error policy, or to continue paginating?
        const data = result.data?.[paginateKey];
        if (data?.items) {
          data.items.push(...(nextResult.data?.[paginateKey as keyof ReturnType]?.items ?? []));
        }

        if (!result.errors) {
          result.errors = [];
        }

        result.errors.push(...(nextResult.errors ?? []));
        result.data![paginateKey]!.nextToken = nextResult.data?.[paginateKey as keyof ReturnType]?.nextToken;
      }
    }
  }
  return parseWithErrorPolicy(result, errorPolicy);
};

/**
 * Wraps Amplify's GraphQLAPI.graphQL function to automatically retrieve return and variables type from query provided.
 *
 * **Note**
 *
 * In most cases, you should be using a subscription that's already in the autogenerated map. If the map needs updating, run `npm run generate-graphql-map`.
 *
 * If you're using a custom subscription you intend to reuse but doesn't have autogenerated types, add it to GraphQLSubscriptionMapCustom in ./types.
 *
 * Either of the above will allow the function to retrieve all types automatically, so usage will look like below.
 * ```ts
 * const result = await graphQLSubscription({ query: onFooChange, variables }); // variables is automatically OnFooChangeSubscriptionVariables and result is Observable<{ provider: AWSAppSyncRealTimeProvider; value: GraphQLResult<OnFooChangeSubscription>;  }
 * ```
 *
 * If this is an entirely one off usage, you can provide the generics manually as below.
 * ```ts
 * const result = await graphQLSubscription<string, ReturnType, Variables>({ query: customSubscription, variables });
 * ```
 *
 * @param options - GraphQL options object, including subscription string and variables.
 * @param [additionalHeaders] - headers to merge in after any `graphql_headers` set in the config
 * @returns Observable for subscription, with value cast automatically to ReturnType
 *
 * @template Subscription - GraphQL string
 * @template ReturnType - type for value.data
 * @template Variables - type for options.variables
 */
export const graphQLSubscription = <
  Subscription extends string,
  ReturnType extends ReturnFromSubscription<Subscription> = ReturnFromSubscription<Subscription>,
  Variables extends VariablesFromSubscription<Subscription> = VariablesFromSubscription<Subscription>
>(
  options: GraphQLOptions<NoInfer<Variables>, Subscription>,
  additionalHeaders?: Parameters<typeof GraphQLAPI.graphql>[1]
) => {
  assert(
    GraphQLAPI.getGraphqlOperationType(options.query) === 'subscription',
    'Please use `graphQL` for non-subscriptions'
  );
  return GraphQLAPI.graphql(options, additionalHeaders) as Observable<{
    provider: AWSAppSyncRealTimeProvider;
    value: GraphQLResult<ReturnType>;
  }>; // now a safe assertion... mostly
};

/**
 * Automatically retrieve variable types based on the query provided, and create final options shape
 *
 * **Note**
 *
 * In most cases, you should be using a query/subscription that's already in the autogenerated map(s). If the map needs updating, run `npm run generate-graphql-map`.
 *
 * If you're using a custom query/subscription you intend to reuse but doesn't have autogenerated types, add it to GraphQLMapCustom or GraphQLSubscriptionMapCustom in ./types.
 *
 * Either of the above will allow the function to retrieve all types automatically, so usage will look like below.
 * ```ts
 * const options = graphqlOperation(onFooChange, variables); // variables is automatically OnFooChangeSubscriptionVariables
 * ```
 *
 * If this is an entirely one off usage, you can provide the generics manually as below.
 * ```ts
 * const options = graphqlOperation<string, Variables>(customQuery, variables);
 * ```
 * @param query Query/Subscription string
 * @param variables Variables to provide - required if any keys in variables type are required
 * @param authToken
 * @param userAgentSuffix
 *
 * @template Query Query/Subscription string
 * @template Variables type for variables to provide
 */
export const graphqlOperation = <
  Query extends string,
  Variables extends VariablesFromQueryOrSubscription<Query> = VariablesFromQueryOrSubscription<Query>
>(
  query: Query,
  ...[variables, authToken, userAgentSuffix]: [
    ...variables: IfHasRequiredKeys<Variables, [variables: NoInfer<Variables>], [variables?: NoInfer<Variables>]>, // require variables to be passed if any required keys
    authToken?: GraphQLOptions['authToken'],
    userAgentSuffix?: GraphQLOptions['userAgentSuffix']
  ]
) => ({
  query,
  variables,
  authToken,
  userAgentSuffix,
});
